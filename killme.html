<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - cloth simulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				padding: 10px;
				width: 100%;
				text-align: center;
			}

			a {
				text-decoration: underline;
				cursor: pointer;
			}

		</style>
	</head>

	<body>
		<div id="info">Jello Simulation<br/>
			holy fk javascript is op<br/>
		</div>

		<script src="js/three.js"></script>

		<script src="js/WebGL.js"></script>
		<script src="js/OrbitControls.js"></script>

		<script>
            // graphics variables
            var scene, camera, renderer;
            var controls;
            var clock, time;

            // jello variables
            var xSize = 3;
            var ySize = 3;
            var zSize = 3;
            var n = xSize * ySize * zSize; // number of point masses
            var geometry = new THREE.BufferGeometry();
            geometry.dynamic = true;
            var positions = []; // the positions of point masses in strides of 3
            var particles = []; // particles wrapper class
            var springs = []; // springs wrapper class

            // physics variables
            var GRAVITY = new THREE.Vector3(0, -.98, 0); // -9.8 m/s^2
            var TIMESTEP = 1 / 60; // time interval in seconds between each update (60 fps => 1 / 60 seconds per update)
            var MASS = 0.1; // mass of each point mass
            var DAMPING = 0.04; // simulate energy loss
            var K = 3; // spring restoring force
            var restDistance = 1 / xSize; // spring resting length

            // this is just a wrapper class for the Points so we can store previous positions and forces more easily
            function Particle(x, y, z, mass) {
                this.position = new THREE.Vector3();
                this.previous = new THREE.Vector3();
                this.original = new THREE.Vector3();
                this.forces = new THREE.Vector3(0, 0, 0); // forces on particle
                this.mass = mass;

                this.position.set(x, y, z);
                this.previous.set(x, y, z);
                this.original.set(x, y, z);
            }

            // spring wrapper class
            function Spring(p1, p2, restDistance) {
                this.p1 = p1;
                this.p2 = p2;
                this.restDistance = restDistance;
            }

            // add force to a particle
            Particle.prototype.addForce = function (force) {
                this.forces.add(force);
            }

            // integrate forces
            Particle.prototype.integrate = function (timesq) {
                let temp = new THREE.Vector3();
                temp.subVectors(this.position, this.previous);
                temp.multiplyScalar(1 - DAMPING).add(this.position);
                let a = this.forces.multiplyScalar(1 / this.mass);
                temp.add(a.multiplyScalar(timesq));

                this.previous = this.position;
                this.position = temp;
                this.forces.set(0, 0, 0); // reset forces
            }
            
            function satisfyConstraints( p1, p2, distance ) {
                let diff = new THREE.Vector3();
                diff.subVectors( p2.position, p1.position );
                var currentDist = diff.length();
                if ( currentDist === 0 ) return; // prevents division by 0
                currentDist = K * currentDist - distance;

                var correction = diff.multiplyScalar(currentDist);
                var correctionHalf = correction.multiplyScalar( 0.5 );
                p1.addForce( correctionHalf );
                correctionHalf.negate() // add inverse
                p2.addForce(correctionHalf);

            }

            function mapTo3D(i) {
                let z = Math.floor(i / (xSize * ySize));
                i -= z * xSize * ySize;
                let y = Math.floor(i / xSize);
                let x = i % xSize;
                return { x: x, y: y, z: z };
            }

            function mapFrom3D(x, y, z) {
                return x + y * xSize + z * xSize * ySize;
            }

            function init() {
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.6);
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight);
                camera.position.set(1.5, 1.5, 1.5);
                camera.lookAt(scene.position);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                clock = new THREE.Clock();
                time = 0;
                document.body.appendChild(renderer.domElement);
                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.maxPolarAngle = Math.PI * 0.5;
                
                // let groundMaterial = new THREE.MeshLambertMaterial();

				// let mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 100, 100 ), groundMaterial );
				// mesh.position.y = - 10;
				// mesh.rotation.x = - Math.PI / 2;
				// mesh.receiveShadow = true;
				// scene.add( mesh );
            }            
        
            function generatePoints() { // create the point masses for the structure
                for (let i = 0; i < n; i++) {
                    let p = mapTo3D(i);
                    positions.push(p.x / xSize);
                    positions.push(p.y / ySize);
                    positions.push(p.z / zSize);

                    particles.push(
                        new Particle(p.x / xSize, p.y / ySize, p.z / zSize, MASS)
                    );
                }
                let positionAttribute = new THREE.Float32BufferAttribute(positions, 3);
                geometry.addAttribute("position", positionAttribute);
            }
            
            function drawPoints() { // draw the point masses
                let points = new THREE.Points(
                    geometry,
                    new THREE.PointsMaterial({ size: 0.04 })
                );
                scene.add(points);
            }
            
            function drawWireframe() { // draw lines connecting the masses
                let indexPairs = [];
                for (let i = 0; i < n; i++) {
                let p = mapTo3D(i);
                    if (p.x + 1 < xSize) {
                        indexPairs.push(i);
                        indexPairs.push(mapFrom3D(p.x + 1, p.y, p.z));
                        springs.push(new Spring(particles[i], particles[mapFrom3D(p.x + 1, p.y, p.z)], restDistance));
                    }
                    if (p.y + 1 < ySize) {
                        indexPairs.push(i);
                        indexPairs.push(mapFrom3D(p.x, p.y + 1, p.z));
                        springs.push(new Spring(particles[i], particles[mapFrom3D(p.x, p.y + 1, p.z)], restDistance));

                    }
                    if (p.z + 1 < zSize) {
                        indexPairs.push(i);
                        indexPairs.push(mapFrom3D(p.x, p.y, p.z + 1));
                        springs.push(new Spring(particles[i], particles[mapFrom3D(p.x, p.y, p.z + 1)], restDistance));

                    }
                }
                geometry.setIndex(indexPairs);
                let lines = new THREE.LineSegments(geometry, new THREE.LineBasicMaterial());
                lines.frustumCulled = false;
                scene.add(lines);
            }
           
            function drawMesh() { // draw mesh over the whole thing
                let triangles = [];
                for (let i = 0; i < n; i++) {
                    let p = mapTo3D(i);
                    if (p.x + 1 < xSize && p.y + 1 < ySize) {
                        triangles.push(i);
                        triangles.push(mapFrom3D(p.x + 1, p.y, p.z));
                        triangles.push(mapFrom3D(p.x, p.y + 1, p.z));
                    }
                    if (p.x > 0 && p.y > 0) {
                        triangles.push(i);
                        triangles.push(mapFrom3D(p.x - 1, p.y, p.z));
                        triangles.push(mapFrom3D(p.x, p.y - 1, p.z));
                    }
                    
                    if (p.y + 1 < ySize && p.z + 1 < zSize) {
                        triangles.push(i);
                        triangles.push(mapFrom3D(p.x, p.y + 1, p.z));
                        triangles.push(mapFrom3D(p.x, p.y, p.z + 1));
                    }
                    if (p.y > 0 && p.z > 0) {
                        triangles.push(i);
                        triangles.push(mapFrom3D(p.x, p.y - 1, p.z));
                        triangles.push(mapFrom3D(p.x, p.y, p.z - 1));
                    }
                    
                    if (p.x + 1 < xSize && p.z + 1 < zSize) {
                        triangles.push(i);
                        triangles.push(mapFrom3D(p.x + 1, p.y, p.z));
                        triangles.push(mapFrom3D(p.x, p.y, p.z + 1));
                    }
                    if (p.x > 0 && p.z > 0) {
                        triangles.push(i);
                        triangles.push(mapFrom3D(p.x - 1, p.y, p.z));
                        triangles.push(mapFrom3D(p.x, p.y, p.z - 1));
                    }
                }

                geometry.setIndex(triangles);
                let mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 'crimson', side: THREE.DoubleSide}));
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.frustumCulled = false;

                scene.add(mesh);
            }

            function simulate(delta) {
                if (delta < TIMESTEP) return;
                
                // apply gravity
                for (let i = 0; i < n; i++) {
                    let copy = new THREE.Vector3().copy(GRAVITY);
                    particles[i].addForce(copy.multiplyScalar(particles[i].mass)); // need to make a copy                    
                }

                // apply springs

                // for (let i = 0; i < springs.length; i++) {
                //     let spring = springs[i];
                //     satisfyConstraints(spring.p1, spring.p2, spring.restDistance);
                // }

                for (let i = 0; i < n; i++) {
                    particles[i].integrate(delta * delta);                 
                }

                // // floor constraints
                // for (let i = 0; i < n; i++) {
                //     let pos = particles[i].position;
                //     if (pos.y < -10) {
                //         pos.y = -10;
                //     }                
                // }

                // satisfy constraints
            }
            
            function render() {
                requestAnimationFrame(render);
                time += clock.getDelta();
                simulate(time);
                for (let i = 0; i < n; i++) {
                    let pos = particles[i].position;
                    console.log(pos);
                    geometry.attributes.position.array[3 * i + 0] = pos.x;
                    geometry.attributes.position.array[3 * i + 1] = pos.y;
                    geometry.attributes.position.array[3 * i + 2] = pos.z;
                }
                geometry.attributes.position.needsUpdate = true;
                renderer.render(scene, camera);
            }

            // main code

            init();
            generatePoints();
            drawPoints();
            drawWireframe();
            drawMesh();
            render();
		</script>
	</body>
</html>